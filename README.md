# Модуль расчёта и отображения полной информации о тренировках по данным от блока датчиков.

## Задача
Реализовать программный модуль по методологии ООП для расчёта и отображения информации
о прошедшей тренировке по данным от блока датчиков.

## Задание
Ваша задача — разработать программный модуль фитнес-трекера, который обрабатывает данные для трех видов тренировок: для бега, спортивной ходьбы и плавания.
Этот модуль
* принимает от блока датчиков информацию о прошедшей тренировке,
* определяет вид тренировки,
* рассчитывает результаты тренировки,
* выводит информационное сообщение о результатах тренировки.

Информационное сообщение должно включать такую информацию:
* тип тренировки (бег, ходьба или плавание);
* длительность тренировки
* дистанция, которую преодолел пользователь, в километрах;
* среднюю скорость на дистанции, в км/ч;
* расход энергии, в килокалориях.

### Структура программы
Каждый вид спортивной активности в модуле должен быть описан соответствующим классом:
* Бег → `class Running` ;
* Спортивная ходьба → `class SportsWalking` ;
* Плавание → `class Swimming` .

Конструктор каждого из классов должен получать информацию с датчиков:
* `action`, тип `int` — количество совершённых действий (число шагов при ходьбе и беге либо гребков — при плавании);
* `duration`, тип `float` — длительность тренировки;
* `weight`, тип `float` — вес спортсмена.

Чтобы определить дистанцию, которую преодолел спортсмен, нужно число шагов или гребков, переданное в action, перевести в километры.

Для расчёта нужно добавить атрибуты класса:
* `LEN_STEP` — расстояние, которое спортсмен преодолевает за один шаг или гребок. 
Один шаг — это  0.65 метра, один гребок при плавании — 1.38 метра.
* `M_IN_KM` — константа для перевода значений из метров в километры. Её значение — 1000.

Методы классов, которые отвечают за обработку данных:
* расчёт дистанции, которую пользователь преодолел за тренировку: `get_distance()`;
* расчёт средней скорости движения во время тренировки:` get_mean_speed()`;
* расчёт количества потраченных калорий за тренировку: `get_spent_calories()`;
* создание объекта сообщения о результатах тренировки: `show_training_info()`.


## Базовый класс Training
```python
class Training
```
В классах, описывающих любой из видов тренировки, применяются одни и те же свойства и методы. Чтобы избежать дублирования кода, необходимо создать базовый класс `Training`. Он должен содержать все основные свойства и методы для тренировок. Каждый класс, описывающий определённый вид тренировки, будет дополнять и расширять базовый класс.

### Свойства класса

* `action` — основное считываемое действие во время тренировки (шаг — бег, ходьба; гребок — плавание);
* `duration` — длительность тренировки;
* `weight` — вес спортсмена;
* `M_IN_KM` = 1000 — константа для перевода значений из метров в километры;
* `LEN_STEP` — расстояние, которое спортсмен преодолевает за один шаг или гребок. Один шаг — это  `0.65` метра, один гребок — `1.38` метра.

### Методы класса

* `get_distance()` — метод возвращает значение дистанции, преодолённой за тренировку.
    ```python
    # базовая формула расчёта
    шаг * LEN_STEP / M_IN_KM
    ```
* `get_mean_speed()` — метод возвращает значение средней скорости движения во время тренировки.
    ```python
    # базовая формула расчёта
    преодоленная_дистанция_за_тренировку / время_тренировки 
    ```
* `get_spent_calories()` — метод возвращает число потраченных калорий, израсходованных за время тренировки.

    Логика подсчета калорий для каждого вида тренировки будет своя, поэтому в базовом классе не нужно описывать поведение метода, в его теле останется ключевое слово pass.
* `show_training_info()` — метод возвращает объект класса сообщения.

## Классы-наследники
### Класс беговой тренировки Running
```python
class Running
```
Все свойства и методы этого класса без изменений наследуются от базового класса. Исключение составляет только метод расчёта калорий, его нужно переопределить.
### Свойства класса

наследуются

### Методы класса
Переопределить метод:
* get_spent_calories() — метод возвращает число потраченных калорий.
    ```python
    # формула расчёта
    (18 * средняя_скорость – 20) * вес_спортсмена / M_IN_KM * время_тренировки_в_минутах
    ```
Важно вынести все неименованные значения в переменные. Это сделает код понятнее для разработчиков, которые будут читать ваш код.
Например:
```python
coeff_calorie_1 = 18
coeff_calorie_2 = 20 
```
---
---
## Класс спортивной ходьбы SportsWalking
Конструктор этого класса принимает дополнительный параметр `height` — рост спортсмена.
```python
class SportsWalking
```
### Свойства класса
Добавляемые свойства:
* `height` — рост

### Методы класса
переопределить метод:
* `get_spent_calories()` — метод возвращает число потраченных калорий.
    ```python
    # формула расчёта
    (0.035 * вес + (скорость ** 2 // рост) * 0.029 * вес) * время_тренировки_в_минутах
    ```
Числовым коэффициентам тоже нужны имена, не забывайте про это.

---
---
## Класс тренировки в бассейне Swimming
```python
class Swimming
```
Конструктор класса `Swimming`, кроме свойств базового класса, принимает еще два параметра:
`length_pool` — длина бассейна в метрах;
`count_pool` — сколько раз пользователь переплыл бассейн.
### Свойства класса
Добавляемые свойства:
* `length_pool` — длина бассейна;
* `count_pool` — количество проплытых бассейнов.

### Методы класса
переопределить метод:
* `get_mean_speed()` — метод возвращает значение средней скорости движения во время тренировки.
    ```python
    # формула расчёта
    длина_бассейна * count_pool / M_IN_KM / время_тренировки
    ```
* `get_spent_calories()` — метод возвращает число потраченных калорий.
    ```python
    # формула расчёта
    (скорость + 1.1) * 2 * вес
    ```
Есть и ещё один параметр, который надо переопределить, ведь расстояние, преодолеваемое за один гребок, отличается от длины шага. Значит, необходимо переопределить атрибут базового класса.

## Класс информационного сообщения InfoMessage
```python
class InfoMessage
```
Это самостоятельный класс для создания объектов сообщений. У этого класса должен быть метод для вывода сообщений на экран.
Объекты этого класса создаются вызовом метода `show_training_info()` для классов тренировок.
### Свойства класса
* `training_type` — тип тренировки;
* `duration` — длительность тренировки;
* `distance` — дистанция, преодолённая за тренировку;
* `speed` — средняя скорость движения;
* `calories` — потраченные за время тренировки килокалории.


### Методы класса
У класса InfoMessage должен быть метод get_message(), который возвращает строку сообщения.

* `get_message()` — метод возвращает строку сообщения.
    ```python
    # выводимое сообщение
    # все значения типа float округляются до 3 знаков после запятой
    'Тип тренировки: {training_type}; Длительность: {duration} ч.; Дистанция: {distance} км; Ср. скорость: {speed} км/ч; Потрачено ккал: {calories}'.
    ```
Числовые значения должны округляться при выводе до тысячных долей (до третьего знака после запятой).

## Имитация получения данных от блока датчиков фитнес-трекера

Прежде чем отдавать модуль в релиз, его работоспособность нужно проверить на реальном фитнес-трекере. Но у разработчиков не всегда есть такая возможность, поэтому можно имитировать работу датчиков и передать в программу заранее подготовленные тестовые данные.

В исходном коде эти данные уже подготовлены:
```python
if __name__ == '__main__':
    packages = [        
        ('SWM', [720, 1, 80, 25, 40]),
        ('RUN', [15000, 1, 75]),
        ('WLK', [9000, 1, 75, 180]),
    ]

    for workout_type, data in packages:
        training = read_package(workout_type, data)
        main(training) 
```
### ```if __name__ == '__main__'```

Файлы Python могут быть запущены как самостоятельные программы, а могут быть импортированы в качестве модулей в какой-то проект. Зачастую бывает необходимо выделить часть кода, которая не должна выполняться при импорте.

Например, тот модуль, который вы напишете в этом задании, впоследствии будет импортироваться в приложение, работающее с фитнес-трекером.

При импорте тестовые данные вашему модулю не потребуются: он будет получать данные прямо с датчиков. Однако, пока вы тестируете свой модуль, запуская его как отдельную программу — тестовые данные вам нужны. Значит, тестовые пакеты должны создаваться только в том случае, если ваш модуль запущен как отдельная программа.

Определить, импортируется ли код из файла, можно по значению переменной `__name__`: если её значение равно `'__main__'` — то файл запущен как самостоятельная программа. Если же код импортируется — значение этой переменной будет содержать имя той программы, в которую импортирован код.
Код, размещённый в теле конструкции `if __name__ == '__main__'`, выполнится только в тех случаях, когда файл запущен как самостоятельная программа.
### Данные для тестов

Блок датчиков фитнес-трекера передает пакеты данных в виде кортежа, первый элемент которого — кодовое обозначение прошедшей тренировки, второй — список показателей полученных от датчиков устройства. Для проверки были смоделированы пакеты для каждого вида тренировки и добавлены в список `packages`.
```python
 packages = [
     ('SWM', [720, 1, 80, 25, 40]),
     ('RUN', [15000, 1, 75]),
     ('WLK', [9000, 1, 75, 180]),
 ] 
```
Последовательность данных в принимаемых пакетах:
#### Плавание
* Код тренировки: `SWM`
* Элементы списка: количество гребков, время в часах, вес пользователя, длина бассейна, сколько раз пользователь переплыл бассейн.
#### Бег
* Код тренировки: `RUN`
* Элементы списка: количество шагов, время тренировки в часах, вес пользователя.
#### Спортивная ходьба
* Код тренировки: `WLK`
* Элементы списка: количество шагов, время тренировки в часах, вес пользователя, рост пользователя.

Программа перебирает в цикле список пакетов, распаковывает каждый кортеж и передаёт данные в функцию `read_package()`.

### Функция чтения принятых пакетов `read_package()`

Функция `read_package()` принимает на вход код тренировки и список её параметров.
Скопировать код
```python
read_package(workout_type, data) 
```
В теле функции должен быть словарь, в котором сопоставляются коды тренировок и классы, которые нужно вызвать для каждого типа тренировки.

Функция должна определить тип тренировки и создать объект соответствующего класса, передав ему на вход параметры, полученные во втором аргументе. Этот объект функция должна вернуть.

### Функция main()

Функция `main()` должна принимать на вход экземпляр класса `Training`.
* При выполнении функции `main()` для этого экземпляра должен быть вызван метод `show_training_info()`; результатом выполнения метода должен быть объект класса `InfoMessage`, его нужно сохранить в переменную `info`.
* Для объекта `InfoMessage`, сохранённого в переменной `info`, должен быть вызван метод, который вернет строку сообщения с данными о тренировке; эту строку нужно передать в функцию `print()`.

## Функции модуля
```python
def read_package()
```
* Функция `read_package()` принимает на вход код тренировки и список её параметров.
* Функция должна определить тип тренировки и создать объект соответствующего класса,
передав ему на вход параметры, полученные во втором аргументе. Этот объект функция должна вернуть.

---
---
```python
def main(training)
```
Функция `main()` должна принимать на вход экземпляр класса `Training`.

– При выполнении функции `main()`для этого экземпляра должен быть вызван метод `show_training_info()`;
результатом выполнения метода должен быть объект класса `InfoMessage`, его нужно сохранить в переменную `info`.
– Для объекта `InfoMessage`, сохранённого в переменной `info`, должен быть вызван метод,
который вернёт строку сообщения с данными о тренировке; эту строку нужно передать в функцию `print()`.
